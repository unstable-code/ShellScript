#!/usr/bin/env bash

use_local_versions=0
extract_versions_only=0
auto_restart_enabled=no

PAGE_SIZE=${PAGE_SIZE:-25}
USER_TIMEOUT=10

if [ "$1" == "--help" -o "$1" == "help" ]; then
    echo "usage: $0 [option|FILE]"
    echo -e '\n\e[0;1mOPTIONS\e[m'
    echo -e "--help\t\tshow this help."
    echo -e "--extract\tdownload gitlab-ce released tags file in Docker Hub. (aka. export)"
    echo -e "\t\ttags file will be saved to /tmp/gitlab-released-tags.txt"
    echo -en "FILE\t\tusing provided file with already ASC sorted contents"
    echo -e '\n\e[0;1mENV VALUES\e[m'
    echo -e "TARGET_URL\tA simple connection test for your GitLab server."
    echo -e "PAGE_SIZE=25\thow many spolling amount each page."
    exit 0
elif [ -f "$1" ]; then
    echo "using $1 file to take effect reducing time about sorting version tags"
    cat -A "$1" | tail -n1 | grep '\$' &> /dev/null
    if [ $? -ne 0 ]; then
        echo '' >> "$1"
    fi

    cat "$1" | grep -viE '(rc|nightly|latest)' | tee "$1" > /dev/null
    requirements=$(cat "$1" | grep -cE '^[0-9]+\.[0-9]+\.[0-9]+-ce\.[0-9]+$')
    total=$(cat "$1" | wc -l)
    if [ $requirements -ne $total ]; then
        echo "error: provided file contents does not containing gitlab-ce version tags" >&2
        cat "$1" | head -n 10 >&2
        exit 1
    else
        use_local_versions=1
    fi
elif [ "$1" == "--extract" -o "$1" == "extract" ] || [ "$1" == "--export" -o "$1" == "export" ]; then
    extract_versions_only=1
fi

which docker &> /dev/null
if [ $? -ne 0 ]; then
    echo "This system did not installed docker yet. $(uname -a)" >&2
    echo 'Please install docker or Container Manager before running this script.' >&2
    echo -e '\nref:\n\thttps://docs.docker.com/engine/install/\n\thttps://www.synology.com/dsm/feature/container-manager' >&2
    exit 1
fi

id | grep docker &> /dev/null
if [ $? -ne 0 -a $UID -ne 0 ]; then
    echo "the $USER user does not have enough docker.sock permission." >&2
    exit 1
fi

CURRENT_VERSION=$(docker exec gitlab dpkg -l | grep gitlab | awk '{ print $3 }')
if [ -z $CURRENT_VERSION ]; then
    exit 1
fi

start_time=$SECONDS

draw_progress() {
    local current=$1
    local total=$2
    local bar_length=30
    local prefix=$3
    local item_name=$4

    # 진행률 계산
    local progress=$(( current * 100 / total ))

    # 채워진 길이 계산
    local filled=$(( progress * bar_length / 100 ))
    local empty=$(( bar_length - filled ))

    # 바 만들기
    local bar=$(printf "%0.s=" $(seq 1 $filled))
    local spaces=$(printf "%0.s " $(seq 1 $empty))

    # 경과 시간
    local elapsed=$(( SECONDS - start_time ))

    # ETA 계산 (index > 0일 때만)
    local eta=$(( elapsed * (total - current) / current ))

    # ETA를 HH:MM:SS로 변환
    local h=$(( eta / 3600 ))
    local m=$(( (eta % 3600) / 60 ))
    local s=$(( eta % 60 ))

    # 출력
    printf "\r%s: [%s>%s] %d%% (%s %d/%d) ETA %02d:%02d:%02d" \
        "$prefix" "$bar" "$spaces" "$progress" "$item_name" "$current" "$total" $h $m $s

    # 마지막이면 줄바꿈
    if (( current == total )); then
        echo ""
    fi
}

if [ $use_local_versions -ne 1 ]; then
    TAGS_URL="https://hub.docker.com/v2/repositories/gitlab/gitlab-ce/tags/?page_size=$PAGE_SIZE"

    # 1. 첫 페이지 요청
    RESPONSE=$(curl -sL "$TAGS_URL")
    TOTAL_COUNT=$(echo "$RESPONSE" | jq '.count')

    # 2. 전체 페이지 수 계산
    TOTAL_PAGES=$(( (TOTAL_COUNT + PAGE_SIZE - 1) / PAGE_SIZE ))

    ALL_TAGS=()

    echo "Spolling GitLab-CE container tags... location: $TAGS_URL"
    while [ -n "$TAGS_URL" ]; do
        RESPONSE=$(curl -sL "$TAGS_URL")
        TAGS=$(echo "$RESPONSE" | jq -r '.results[].name')
        if [ -z "$TAGS" ]; then
          break  # 더 이상 태그 없음
        else
            CURRENT_PAGE=$(echo "$TAGS_URL" | grep -oP 'page=\K[0-9]+' || echo 1)
            draw_progress $CURRENT_PAGE $TOTAL_PAGES 'Querying GitLab Releases' 'Page'
        fi
        ALL_TAGS+=($TAGS)
        TAGS_URL=$(echo "$RESPONSE" | jq -r '.next')
    done

    echo -e "\nSorting ASC GitLab-CE released tags..."

    # 버전 정렬
    printf '%s\n' "${ALL_TAGS[@]}" > /tmp/gitlab-parsed.log
    cat /tmp/gitlab-parsed.log | tr ' ' '\n' | tee /tmp/gitlab-parsed.log > /dev/null

    RAW_TAGS_N=$(cat /tmp/gitlab-parsed.log | sort -V | grep -viE '(rc|nightly|latest)')
    count=1
    mapfile -t RAW_TAGS <<< "$RAW_TAGS_N"

    ALL_TAGS=()
    for idx in "${!RAW_TAGS[@]}"; do
        tag="${RAW_TAGS[$idx]}"
        if [ $extract_versions_only -eq 1 ]; then
            draw_progress $count ${#RAW_TAGS[@]} "Exporting provided contents" 'Item'
        else
            draw_progress $count ${#RAW_TAGS[@]} "Including provided contents" 'Item'
        fi

        # 배열에 추가
        ALL_TAGS+=("$tag")
        count=$((count + 1))

        # 첫 번째 비교
        if [ $((idx + 1)) -lt ${#RAW_TAGS[@]} ]; then
            next_tag="${RAW_TAGS[$((idx + 1))]}"
            first=$(printf '%s\n%s\n' "$tag" "$next_tag" | sort -V | head -n1)
            if ! [[ "$first" == "$tag" ]]; then
                echo -e "\nerror: tags are NOT in ASC order: $tag > $next_tag" >&2
                exit 1
            fi
        fi
    done
    rm /tmp/gitlab-parsed.log 2> /dev/null

    if [ $extract_versions_only -eq 1 ]; then
        echo "${ALL_TAGS[@]}" | tr ' ' '\n' > /tmp/gitlab-released-tags.txt
        if [ $(cat /tmp/gitlab-released-tags.txt | wc -l) -gt 3 ]; then
            echo -e '\nnote: successfully export gitlab-ce released tags. please sort ASC order these tags. location: /tmp/gitlab-released-tags.txt'
            exit 0
        else
            echo -e '\nerror: failed to export gitlab-ce released tags. internal error occurred.' >&2
            rm /tmp/gitlab-released-tags.txt &> /dev/null
            exit 1
        fi
    fi
else
    cat "$1" | tr ' ' '\n' | tee "$1" > /dev/null
    RAW_TAGS_N=$(cat "$1" | sort -V | grep -viE '(rc|nightly|latest)')
    count=1
    mapfile -t RAW_TAGS <<< "$RAW_TAGS_N"

    for idx in "${!RAW_TAGS[@]}"; do
        tag="${RAW_TAGS[$idx]}"
        draw_progress $count ${#RAW_TAGS[@]} "Importing provided contents" 'Item'

        # 배열에 추가
        ALL_TAGS+=("$tag")
        count=$((count + 1))

        # 첫 번째 비교
        if [ $((idx + 1)) -lt ${#RAW_TAGS[@]} ]; then
            next_tag="${RAW_TAGS[$((idx + 1))]}"
            first=$(printf '%s\n%s\n' "$tag" "$next_tag" | sort -V | head -n1)
            if ! [[ "$first" == "$tag" ]]; then
                echo -e "\nerror: tags are NOT in ASC order: $tag > $next_tag" >&2
                exit 1
            fi
        fi
    done
fi

# 1. 현재 버전 이후만 필터링
UPDATABLE_TAGS=()

count=1
for idx in "${!ALL_TAGS[@]}"; do
    tag="${ALL_TAGS[$idx]}"
    draw_progress $count ${#ALL_TAGS[@]} "Listing tags after $CURRENT_VERSION" 'Item'

    # 현재 버전보다 최신이면 배열에 추가
    if [[ "$(printf '%s\n%s\n' "$CURRENT_VERSION" "$tag" | sort -V | head -n1)" != "$tag" ]]; then
        UPDATABLE_TAGS+=("$tag")
    fi
    count=$((count + 1))
done

# 2. 마이너 릴리즈별 첫/최신 버전 선택
declare -A MINOR_FIRST
declare -A MINOR_LATEST
count=1
for idx in "${!UPDATABLE_TAGS[@]}"; do
    tag="${UPDATABLE_TAGS[$idx]}"
    minor=$(echo "$tag" | cut -d. -f1,2)
    draw_progress $count ${#UPDATABLE_TAGS[@]} "Creating Upgrade Path" 'Item'
    # 첫 번째 발견 시 저장
    if [[ -z "${MINOR_FIRST[$minor]}" ]]; then
        MINOR_FIRST[$minor]="$tag"
    fi
    # 최신 버전 비교
    if [[ -z "${MINOR_LATEST[$minor]}" ]] || [[ "$(printf '%s\n%s\n' "${MINOR_LATEST[$minor]}" "$tag" | sort -V | tail -n1)" == "$tag" ]]; then
        MINOR_LATEST[$minor]="$tag"
    fi
    count=$((count + 1))
done

# 결과 확인
mapfile -t UPGRADE_POINTS_ARRAY < <(
    for minor in $(printf '%s\n' "${!MINOR_FIRST[@]}" | sort -V); do
        echo "${MINOR_FIRST[$minor]}"
        if [[ "${MINOR_FIRST[$minor]}" != "${MINOR_LATEST[$minor]}" ]]; then
            echo "${MINOR_LATEST[$minor]}"
        fi
    done
)

if [ -z "$TARGET_URL" ]; then
    echo 'TARGET_URL does not configured yet. please enter your GitLab server URL.'
    echo 'ex: https://gitlab.com'
    echo -n '> '
    TARGET_URL=$(read n && echo $n)
    if [ -z "$TARGET_URL" ]; then
        echo 'User abort'
        exit 1
    fi
fi

if [ ${#UPGRADE_POINTS_ARRAY[@]} -eq 0 ]; then
    echo "requirements already satisfied: v$CURRENT_VERSION"

    curl -sf -o /dev/null $TARGET_URL/explore/projects &> /dev/null
    if [ $? -ne 0 ]; then
        echo "NOTE: If your GitLab server does not work properly, please edit $(docker inspect gitlab --format='{{range .Mounts}}{{.Source}}:{{.Destination}} {{end}}' | tr ' ' '\n' | grep /etc/gitlab | awk -F ':' '{ print $1 }')/gitlab.rb file or 'docker exec -it gitlab /bin/bash && vi /etc/gitlab/gitlab.rb'"
    fi
    exit 0
fi

echo -e "\nWould you like to upgrade GitLab server from $CURRENT_VERSION to ${UPGRADE_POINTS_ARRAY[-1]}?"
echo "This action can not be undo. PLEASE BACKUP gitlab drive BEFORE STARTING UPDATE..."
echo "You should update pointing release either. ROUTING COUNT: ${#UPGRADE_POINTS_ARRAY[@]}"
echo -e "\t1. I understood which this action DID NOT SUPPORTed rollback"
echo -e "\t2. I understood which this action did not end shortly cuz ROUTING COUNT reason."
echo -e "\t3. I checked container restart policy: $(docker inspect --format='{{.HostConfig.RestartPolicy.Name}}' gitlab)"
echo -e "\t4. I checked container PORTS: $(docker ps --format='{{.Names}} {{.Ports}}' | grep gitlab | sed 's/gitlab //')"
echo -e "\t5. I checked container DRIVE: $(docker inspect gitlab --format='{{range .Mounts}}{{.Source}}:{{.Destination}} {{end}}')"
echo -e "\t6. I checked PAGE_SIZE and TARGET_URL values: PAGE_SIZE: $PAGE_SIZE, TARGET_URL: $TARGET_URL"
echo -en "\nI accepted above notice and continue this job (y/N) > "
read n
if ! [ "$n" == "y" -o "$n" == "Y" ]; then
    echo 'User abort' >&2
    exit 1
fi

auto_restart_enabled=$(docker inspect --format='{{.HostConfig.RestartPolicy.Name}}' gitlab)

# --------------------------
# 1️⃣ 볼륨 마운트 추출
# --------------------------
VOLUMES=$(docker inspect gitlab --format='{{range .Mounts}}{{.Source}}:{{.Destination}} {{end}}' \
    | tr ' ' '\n' \
    | sed '/^$/d' \
    | awk '{printf "-v %s ", $0}' \
    | sed 's/ $//')

# --------------------------
# 2️⃣ 포트 매핑 추출
# --------------------------
PORTS=$(docker inspect gitlab --format='{{range $p, $conf := .HostConfig.PortBindings}}{{$p}}:{{(index $conf 0).HostPort}} {{end}}' \
    | tr ' ' '\n' \
    | sed '/^$/d' \
    | sed 's/\/tcp//g' \
    | awk -F: '{printf "-p %s:%s ", $2, $1}')

index=1
CNT_VERSION=$CURRENT_VERSION
for ver in "${UPGRADE_POINTS_ARRAY[@]}"; do
    echo "updating $CNT_VERSION to $ver... ($index/${#UPGRADE_POINTS_ARRAY[@]})"
    docker ps -a | grep gitlab &> /dev/null
    if [ $? -eq 0 ]; then
        echo -n "stopping $CNT_VERSION container with SIGINT signal..."
        docker stop gitlab &> /dev/null
        echo ' done'
    fi
    echo -n "removing $CNT_VERSION container..."
    docker container rm gitlab &> /dev/null
    echo ' done'

    echo -n "removing previous $CNT_VERSION image..."
    docker image rm $(docker images | grep gitlab/gitlab-ce | awk '{ print $3 }') &> /dev/null
    echo ' done'

    CNT_VERSION=$ver
    docker pull gitlab/gitlab-ce:$ver
    docker run -d --name gitlab $VOLUMES $PORTS gitlab/gitlab-ce:$ver

    echo -n "waiting until gitlab/gitlab-ce:$ver server to boot... "
    spinner='/-\|'
    n=${#spinner}
    echo -n ' '
    while [ $(curl -sf -o /dev/null $TARGET_URL/explore/projects -w "%{http_code}\n") != '200' ]; do
        printf '\b%s' "${spinner:i++%n:1}"
        sleep 1
    done
    printf '\b\b%s' " "
    echo 'done'

    if [ $(docker inspect --format='{{.State.ExitCode}}' gitlab) -ne 0 ]; then
        echo -e "\nerror: gitlab/gitlab-ce:$ver container was died with following status code: $(docker inspect --format='{{.State.Health.Status}}' gitlab). manually action required." >&2
        echo -e "\tenter 'docker logs gitlab' command to get more infomations" >&2
        exit 1
    else
        echo -n "waiting until gitlab/gitlab-ce:$ver container is ready... "
        spinner='/-\|'
        n=${#spinner}
        echo -n ' '
        while [ $(docker inspect --format='{{.State.Health.Status}}' gitlab | grep -c healthy) -ne 1 ]; do
            printf '\b%s' "${spinner:i++%n:1}"
            sleep 1
        done
        printf '\b\b%s' " "
        echo 'done'
    fi

    if [ $index -lt ${#UPGRADE_POINTS_ARRAY[@]} ]; then
        echo "gitlab-ce $ver update completed. remaining jobs: $((${#UPGRADE_POINTS_ARRAY[@]} - index - 1))"
    else
        echo "gitlab-ce $ver update completed."
    fi
    index=$((index + 1))
done

if [ "$auto_restart_enabled" != "$(docker inspect --format='{{.HostConfig.RestartPolicy.Name}}' gitlab)" ]; then
    docker update --restart=$auto_restart_enabled gitlab
    echo "update gitlab RestartPolicy $(docker inspect --format='{{.HostConfig.RestartPolicy.Name}}' gitlab) to $auto_restart_enabled "
fi

echo "Successfully updated Gitlab server from $CURRENT_VERSION to ${UPGRADE_POINTS_ARRAY[-1]}"
echo "Updated traceroute: ${UPGRADE_POINTS_ARRAY[@]}"

exit 0
